# 다른 페이지 처리하기
- 현재 작성한 기능은 HTTP 요청으로 부터 ToDoList가 포함된 HTML 문서를 반환하는 함수를 만들었다. 새로운 기능을 추가하려면 어떻게 해야 할까?
- 기존에 작성한 함수는 건들지 않겠다. 그 함수는 그대로 완성된 함수이며, 다른 종류의 호출을 신경 쓰지 않아야 한다.
- 하드코딩된 값으로 너무 구체적인 함수를 작성하는 것도 원치 않는다. 재사용하기 힘들기 때문이다.
- 서로 다른 종류의 Request를 처리하는 함수를 기존 코드를 변경하지 않고 어떻게 결합할 수 있을까?
  - 함수 컬렉션을 입력으로 받고 새 함수를 반환하는 함 수가 필요하다.

# 함수적 의존관계 주입
- 코드에서 외부 의존관계를 사용해야 하는 경우, 이를 직접 생성하지 말고 외부에서 전달받아야 한다
- 외부 의존관계의 생성과 사용을 분리하면 서로 다른 동작을 기대하는 여러 구현을 전달할 수 있기 때 문에 코드가 더 유연하고 테스트하기 좋아진다.
- 허브가 외부 리소스에 대한 접근을 위임하는 방법, 즉 허브 내부에 함수를 주입해 도메인에서 외부 서 비스와 통신할 수 있도록 허용하는 방법을 알아보자

## 객체 지향 의존관계 주입
- 객체 지향에서 `의존 관계의 생성`: 어떤 객체를 직접 만들어내는 것
- 객체 지향에서 `의존 관계의 사용`: 생성한 객체의 기능을 사용하는 것
- 객체 지향에서 `의존관계 주입`: 객체에게 필요한 의존관계(객체)를 객체가 스스로 생성하는 대신 외부에서 전달받는 것
  - 필요한 객체를 생성자, 메서드로 주입 or 애너테이션이나 외부 구성 파일 같은 메타 프로그래밍 기법을 사용해 주입

## 함수형 의존관계 주입
- 함수형 프로그래밍에선 객체보다 함수를 더 선호한다
  - 의존관계를 함수로 주요 함수에 전달해야 한다
  - 의존관계를 인자로 받아들여서 함수 내부에서 그 의존관계를 포함하는 함수를 생성하는 다른 함수를 사용하는 것!

## 커링(currying)
- 함수를 여러 개의 인자를 받는 형태에서, 하나의 인자만 받는 함수들의 연쇄로 바꾸는 개념

## 함수의 부분 적용 기법 (Partial Application)
- 함수의 일부 인자만 고정해서 새로운 함수를 만드는 것.

```kotlin
fun <A,B,C,R> partial(f: (A,B,C) -> R, a: A): (B,C) -> R = { 
  b, c -> f(a,b,c)
}
```
- 해석하면 아래와 같다
```kotlin
fun <A, B, C, R> partial(
    f: (A, B, C) -> R,  // 세 개의 인자를 받아 R을 반환하는 함수
    a: A                // 첫 번째 인자 고정값
): (B, C) -> R =        // 반환 타입: 두 인자를 받는 함수
    { b, c -> f(a, b, c) } // 고정된 a와 새로운 b, c를 사용해 f를 호출
```
- `<A, B, C, R>`: 제네릭 타입 매개변수 4개 (입력 3개, 반환 1개)
- `f: (A, B, C) -> R`: 세 개의 인자를 받아 결과를 내는 함수
- `a: A`: f의 첫 번째 인자를 고정할 값
- 반환값: `(B, C) -> R`
  즉, 이제 두 개의 인자만 받는 새 함수를 만들어 반환

### `partial` 함수 사용 예제
```kotlin
fun <A,B,C,R> partial(f: (A,B,C) -> R, a: A): (B,C) -> R = { 
  b, c -> f(a,b,c)
}

fun greet(hour: Int, name: String, punctuation: String): String {
    return "Good ${if (hour < 12) "morning" else "evening"}, $name$punctuation"
}

val greetAt9 = partial(::greet, 9) // hour를 9로 고정
val message1 = greetAt9("Alice", "!") // "Good morning, Alice!"
val message2 = greetAt9("Rapunzel", "?") // "Good morning, Rapunzel?"
```

# 함수형 방식으로 도메인을 모델링하는 방법

## 객체 지향 디자인
- 비즈니스 엔터티를 식별하는 것부터 시작(고객, 주문, 제품, 송장과 같은 실제 개념)
- 엔터티들을 코드의 클래스로 매핑하고 특정 개념의 동작을 캡슐화
  - e.g. 고객의 이름, 연락처, 구매 내역 등의 데이터와 주문이나 프로필 갱신 등의 행동을 캡슐화하는 Customer 클래스

## 함수형 디자인
- 데이터 타입의 변환(화살표)과 그런 변환의 합성을 기반
- 비즈니스 프로세스를 매핑할 때는 비즈니스 엔터티에 초점을 맞추지 않고 교환되는 데이터와 그 변환에 초점을 맞춤
  - e.g. 일부 데이터(CustomerOrder)를 가져오는 함수를 정의한 다음, 약간의 계산(주문의 총 비용 계산)을 수행하고, 다른 데이터(최종 Invoice)를 출력으로 반환하는 함수를 정의

## 낮은 카디널리티 타입 사용하기
- 타입의 카디널리티(cardinality)란 모든 가능한 값의 개수
  - e.g. `bool` 타입은 값이 `true`, `false`로 카디널리티가 `2`
- 카디널리티를 낮게 유지하면 도메인에서 실제 의미가 없는 값을 타입이 표현하지 못하게 할 수 있다.
- 데이터를 그 소스 근처에서 막음으로써 손상 방지 계층(anti-corruption layer)으 로 작용해 잘못된 데이터가 시스템에 유입되지 못하게 막는다
- 도메인의 맥락에서 의미 있는 값으로만 값을 조작하도록 제한한다
- 전체 애플리케이션 상태를 더 쉽게 이해할 수 있으며, 중간중간 추가해야 하는 검사도 줄일 수 있다.
- **신뢰할 수 없는 소스의 데이터를 검증하는 구체적인 생성자를 만들어 보자!**
