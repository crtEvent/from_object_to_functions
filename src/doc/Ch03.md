- 2장에선 단순한 순수 함수들을 함성해 복잡한 동작을 얻는 방법, HTTP 호출을 함수로 처리하는 법을 배웠음
- 3장에선 고차 함수를 사용하는 법, 'ports and adapters architecture' 의 이점을 배움

# 3.1 인수 테스트 개선
- 인수 테스트가 지켜야할 원칙
  - 도메인 용어만 사용하기(UI, 기술적 세부사항 언급은 X. e.g.'전송버튼 클릭', 'HTTP 헤터가 있는지 확인' 등)
  - 각 테스트는 유스케이스 시나리오를 나타냄. 테스트가 사용자 스토리를 형성함
  - 테스트는 액터와 상호작용에 초점을 맞춤
  - 단언문은 명확한 도메인 이름을 가진 메서드로 표현함

## 시나리오 액터 추가
- 사용자의 상호작용에 더 집중하고 싶다. 테스트에서 불필요한 세부정보를 제거하자
- 시나리오 액터를 추상화해 추출하여 액터 클래스에 대한 단언문을 정의할 수 있다
  - 액터를 독립적인 클래스(또는 객체)로 만들면, 그 클래스 내부에서 다양한 단언문(assertions)을 캡슐화할 수 있다
  - 이렇게 하면, 개별 테스트 코드에서 일일이 assert를 호출하지 않아도 됨.

## panic이 발생하는지 테스트 하기
### `#[should_panic]`
```rust
#[test]
#[should_panic]
fn test_panic() {
    panic!("이 테스트는 패닉이 발생해야 합니다!");
}
```

### `#[should_panic(expected = "특정 패닉 메시지")]`
```rust
#[test]
#[should_panic(expected = "특정 패닉 메시지")]
fn test_panic_with_message() {
  panic!("특정 패닉 메시지");
}
```

### `std::panic::catch_unwind`
```rust
use std::panic;

#[test]
fn test_panic_catch_unwind() {
    let result = panic::catch_unwind(|| {
        panic!("테스트용 패닉");
    });

    assert!(result.is_err());
}
```

# 3.3 인프라에서 도메인 분리하기
- 시스템의 각 모듈에서 변경해야 할 이유는 하나여야 한다.
- 비즈니스 도메인 로직과 기술적 구현을 분리해야 한다.

## 비즈니스 로직과 아닌 것은 어떻게 구분할까?
- 비즈니스 로직은 직렬화, 네트워크 프로토콜, 라우터, JSON 파싱 등의 기술 용어 없이 비즈니스 담당자와 논의할 수 있다.

## 도메인을 다른 도메인과 분리해 순수하게 유지하려면?
- 인터페이스로 모든 도메인 로직을 감싼다. '포트 어탭터' or '헥사고날 아키텍처'
- 도메인 함수를 HTTP 계층에 직접 연결하면 나중에 이 둘을 분리하기 매우 어려워짐
- 도메인을 감싼 인터페이스는 애플리케이션의 중앙에 위치해 허브(Hub) 처럼 작동한다
  - 도메인은 허브 내부에 머무르며 함수를 통해 나머지 애플리케이션/외부와 소통한다
  - 이 방식으로 HTTP 함수와 같은 기술 계층을 변경하지 않고도 비즈니스 로직을 변경할 수 있다

## 우리가 작성했던 함수에서 비즈니스 로직 찾기
- 입력과 출력에 모두 도메인 타입이 있다면? 도메인의 일부일 확률이 높다
  - 나머지는 허브와 외부를 연결하는 스포크에 속한다
- 함수명을 보자 Html, Request, Response 같은 기술 명이 나온다면? 비즈니스 로직이 아닐 것이다

## 허브 인터페이스를 구현할 때 염두해 둘 점
- 허브 내부는 함수적으로 순수하게 만든다
- 허브 기능을 만드는데 필요한 외부 기능은 모두 외부에서만 제공한다